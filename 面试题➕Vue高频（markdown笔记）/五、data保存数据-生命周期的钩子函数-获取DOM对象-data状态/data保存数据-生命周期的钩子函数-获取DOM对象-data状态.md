## 1.为什么组件保存数据的data是一个函数？

- 因为data是一个函数，当我们 **`每复用一次组件，就会返回一个新的data`**  (类似给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据)，如果我们单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。

## 2.组件的生命周期钩子函数，以及各个声明周期函数可以做什么事情？

- beforeCreate
  - `在实例初始化后` ，`在数据观测 (data observer) 和 event/watcher事件配置` 之前被调用。是new Vue()之后触发的第一个钩子函数，在当前阶段中：`data、methods、computed以及watch上的数据和方法`都不能被访问。
- created
  - 在`实例创建完成后`被立即调用。实例已完成以下的配置：`数据观测 (data observer)`， `属性和方法的运算`，`watch/event 事件回调`。但是挂载阶段还没开始，`$el属性目前不可见，无法与Dom进行交互`，如果这个阶段想和Dom交互的话，可以`通过vm.$nextTick来访问Dom`
- beforeMount
  - 在`挂载之前被调用，可以对数据进行更改，不会触发updated`
- mounted
  - `在挂载完成后发生`，在这个阶段，`真实的Dom挂载完毕，数据完成双向绑定`，可以访问到Dom节点，`使用$refs属性对Dom进行操作`
- beforeUpdate                                                                                                                       
  - `数据更新时调用`，响应式数据发生更新，`虚拟dom重新渲染之前被触发`，适合在更新前访问现有的DOM、手动移除已添加的事件监听器  
- updated
  - 数据更新后调用，`当前阶段组件Dom已经完成更新`
- activated
  - `keep-alive 组件激活时调用`。该钩子在服务器端渲染期间不被调用。
- deactivated
  - `keep-alive 组件停用时调用`。该钩子在服务器端渲染期间不被调用。
- beforeDestroy
  - 实例销毁之前调用。在这一步，`实例仍然完全可用`。我们可以在这个时候`进行善后收尾工作，如清除计时器等`。
- destroyed
  - Vue实例销毁后调用。Vue实例指示的`所有东西都会解绑定`，`所有的事件监听器会被移除，所有的子实例也会被销毁`。
- errorCaptured
  - 当`捕获一个来自子孙组件的错误时被调用`。此钩子会收到 **`三个`** 参数：
    - `错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串`。
    - 此钩子`可以返回 false`以阻止该错误继续向上传播。

## 3.vue中如何获取DOM对象

- 直接在 **`标签中使用ref属性`** **`<van-nav-bar ref="nav"> </van-nav-bar>`**
- 直接 **`获取该组件对象`** **`cont navbar = this.$refs.nav`** 

## 4.data改变更新DOM是同步还是异步的?怎么访问到更新后的DOM呢?

**`（DOM更新是异步的）`**:在函数内操作数据造成视图更新，此时无法拿到更新后的DOM

解决方法:

- update() { 钩子函数内拿到更新后的DOM }
- this.$nextTick(() = { 获取更新的DOM })
- 定时器内

