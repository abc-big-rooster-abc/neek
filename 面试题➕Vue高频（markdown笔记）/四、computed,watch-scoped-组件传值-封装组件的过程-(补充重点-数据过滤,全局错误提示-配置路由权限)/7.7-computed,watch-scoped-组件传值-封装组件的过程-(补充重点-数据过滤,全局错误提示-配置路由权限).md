## 1.计算属性computed和侦听属性watch的相同点和不同点是什么?

计算属性 computed 可以 **`代替{{ }}模板中复杂的计算逻辑`** ，具有 **`响应`** 功能，监听在 **`data(),props,vuex`**中定义的**`一个/多个`** 属性，并返回计算后的值。

监听属性 watch --> 监听 **`data(),props`** 等某个 **`属性值的变化`**

- 相同点：都具有 **`监听属性变化`** 的功能
- 不同点：
  - computed能完成的功能，watch都可以完成
  - watch能完成的功能，computed不一定能完成，因为 **`computed是同步的(有return)`** ，**`watch是异步的(没有return)`**(例如：定时器)
  - computed中的函数是 **`带返回值的`** ，wacth里面的函数 **`可以不写返回值`**

## 2.组件中style标签的scoped作用是什么? 什么原理?

### 2.1-scoped作用：

实现 **`组件的私有化`** ，不会对全局造成样式污染，表示当前style属性只作用于当前组件模块

### 2.2-原理：

scoped会在DOM结构和CSS样式上加上唯一性标识 **`[data-v-something]`** 属性，那就意味着CSS带属性选择器，那我们就可以采用类似作用域的选择方式，从而达到样式私有化，不污染全局的作用。

### ~~？2.3-怎么在第三方组件中修改样式(面试补充)~~

~~比如当我们在使用elementUI时，使用scoped会出现 CSS 设置不起效的问题，无法通过 CSS 修改组件的样式。~~

- ~~使用 **`>>>`** 可以 **`穿透scoped`** 属性，修改其他第三方组件的样式~~

- ~~使用 **`sass/less`** 的样式穿透--> **`/deep/`**~~

- ~~使用两个style标签，一个带scoped属性，一个不带scoped属性，用来修改第三方组件的样式~~

  ![怎么在第三方组件中修改样式](https://chenwei-blog-1301583529.cos.ap-chengdu.myqcloud.com/7.7-%E9%9D%A2%E8%AF%95%E9%A2%982.3-3.png)

## 3.组件传值的方式? 

 ![组件传值的方式-总结图](https://chenwei-blog-1301583529.cos.ap-chengdu.myqcloud.com/7.7-3-%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F.png)

### 3.1-父组件传给子组件

- props/attrs/refs/provide/vuex

props:在子组件里定义一个props,即props:[‘msg’]，msg可以是 **`对象`** 也可以是 **`基本数据类型`** 。这种传值是 **`单向的`** ，无法改变父组件的值

attrs:一般借助父亲的 **`props作为中间过渡`** ，但是这样的话， 父亲组件中会 **`多出无关的属性，耦合度高`**，那我们可以，借助$attrs简化

refs:通过$ref的能力，给 **`子组件定义一个ID`**，父组件通过这个ID可以 **`直接访问`** 子组件里面的 **`方法和属性`** 

provide:依赖注入，在任何后代组件中，都可以使用provide给当前实例 **`注入父组件的数据/方法`** 

### 3.2-子组件传给父组件

- emit/parents/listeners

emit:需要使用 **`自定义事件`** ，在子组件中使用 **`this.$emit`** (‘myEvent’) 触发，然后在父组件中使用 **`@myEvent监听`**

parents:可以获得父组件实例，然后通过这个实例就可以访问父组件的属性和方法

listeners:借助$listeners中间事件,将数据往上传递

### 3.3-兄弟组件传值

- eventBus:
  - 利用中央事件总线eventbus，
  - 在main.js中把一个空的vue实例挂载在vue的原型上起名叫$bus，传数据的时候用this.$bus.$emit传
  - 在接受数据的子组件上的created钩子函数中用$on方法接收

补充链接(http://t.csdn.cn/D74Fz)

## 4.在公司的项目中封装过组件吗? 说一说封装以及使用的过程?

封装过组件，有用过 **`Vue+elementUI实现提交按钮的封装`** 

因为，我们在设计提交按钮的时候，为了防止用户重复提交，很多时候是用防抖或者节流，

但是在一些特定情况的时候，这样的处理方式不好。比如网络很慢的时候，还是会出现重复提交，

还有就是按钮没有状态显示，用户不知道怎么到底提交了没。

![img](https://chenwei-blog-1301583529.cos.ap-chengdu.myqcloud.com/%E6%8C%89%E9%92%AE%E7%A4%BA%E4%BE%8B.png)

我做的就是给按钮添加一个加载状态，当点击的时候，在提交中有一个loading状态，el-button自带的就有一个loading属性

我们传参的时候，传递一个submit提交函数，是一个Promise，在promise状态改变的时候我们就把loading状态修改为false

这样我们传一个提交函数，返回一个 **`Promise`** 就可以了，点击按钮时就会有加载动画，加载中的时候，按钮是处于禁用状态的，这个时候，我们再次点击提交，是不生效的，就防止了重复提交。

![img](https://chenwei-blog-1301583529.cos.ap-chengdu.myqcloud.com/7.7-4.2-%E6%8C%89%E9%92%AE%E7%BD%91%E7%BB%9C.gif)

补充：封装代码

~~~vue
<template>
  <el-button v-bind="$attrs" :loading="loading" @click="click">
    <slot></slot>
  </el-button>
</template>

<script>
export default {
  name: "SubmitButton",
  props: {
    // 提交函数、
    submit: {
      type: Function,
      require: true,
    },
  },
  data() {
    return {
      loading: false,
    };
  },

  methods: {
    async click() {
      try {
        this.loading = true;
        await this.submit();
      } finally {
        this.loading = false;
      }
    },
  },
};
</script>
~~~

使用：

~~~vue
<template>
	<el-form ref="form" :model="dataForm" :rules="rules">
	  <el-form-item label="用户名" prop="username">
	    <el-input placeholder="请输入用户名" v-model="dataForm.username"></el-input>
	  </el-form-item>
	  <el-form-item>
	    <SubmitButton type="primary" :submit="formSubmit">提 交</SubmitButton>
	  </el-form-item>
	</el-form>
</template>
<script>
export default {
  data() {
    return {
      dataForm: {
        username: "",
      },
      rules: {
        username: [
          {
            required: true,
            message: "请输入用户名",
          }
        ]
      }
    }
  },
  methods: {
    validate() {
      return this.$refs.form.validate();
    },
    async formSubmit() {
      // 表单验证
      await this.validate();
      // 提交表单数据
      await this.$http.post('/api/xxxx', this.dataForm)
      this.$message.success('提交成功！')
      this.$router.back()
    },
  },
};
</script>
~~~

补充链接：http://t.csdn.cn/bQFBM

## 5.响应拦截器: 数据过滤, 全局的错误提示

 ![响应拦截器流程图](https://chenwei-blog-1301583529.cos.ap-chengdu.myqcloud.com/%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8.png)

### 简述:

响应拦截器可以帮我们进行无感刷新，过滤数据，提示全局错误等
当我们收到响应之后先判断响应是否成功，如果响应失败就利用elementUI的Message的消息提示框，提示错误信息，使用Promise.reject方法跳出resolve成功态直接进入失败态，如果是请求成功就进行数据解构，判断是否请求到token，请求到token就返回到data中去，如果没有请求到token就提示错误信息并自定义一个错误跳出成功态。

## 6.**配置路由权限**

![image-20220707212028200](https://chenwei-blog-1301583529.cos.ap-chengdu.myqcloud.com/%E9%85%8D%E5%81%B6%E8%B7%AF%E7%94%B1%E6%9D%83%E9%99%90%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

### 简述：

我们可以在路由全局前置守卫(beforeEach)中设置访问权限，首先判断是否有token，有token说明是已经登录状态，接着判断要跳转到哪个路由，若是要跳转到login页面就强制跳转到首页，如果不是跳转到login页面就放行，如果没有token就判断要跳转的是否是白名单的页面，是白名单的就放行，不是白名单的页面，就需要获取到token权限才能正常访问，我们就让用户强制跳转到login页面